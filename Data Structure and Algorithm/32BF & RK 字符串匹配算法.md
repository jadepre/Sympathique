# 32|BF & RK 字符串匹配算法

## 一、BF算法

Brute Force的缩写，中文称之为暴力匹配算法，也叫朴素匹配算法。

在字符串A中查找字符串B：定义**主串**为字符串A，其长度为n，**模式串**为字符串B，其长度为m。N>M。

**BF算法思想**：在主串中，检查起始位置分别是0、1、2...n-m 且长度为m的n-m+1个子串，看有无与模式串匹配的。

![1561369086585](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1561369086585.png)

最坏情况下，每次对比m个字符，要对比n-m+1次，BF算法时复为O(n*m)。

虽然理论上时复很高，但是现实中比较常用。

* 软件开发过程中，主串和模式串的长度都不会太长。当模式串和主串中途不匹配，就可以停止了，不需要把模式串的m个字符全部匹配。
* 朴素字符串匹配算法思想简单，代码实现也简单。简单，所以不容易出错。如果有BUG也容易暴露和修复。在工程中，在满足性能要求的前提之下，简单是首选，这就是常说的KISS（Keep it Simple and Stupid）设计原则。

## 二、RK算法

Rabin-Karp算法。最早是由两位发明者Rabin 和 Karp 的名字来命名的。

**RK算法思路**：

* 利用哈希算法对主串中的n-m+1个子串分别求取哈希值，逐个与模式串哈希值做对比

* 如果哈希值相等，那么匹配（忽略哈希冲突情况）

  ![1561381941577](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1561381941577.png)

  **优缺点**

* 因为哈希值是数字，那么比较过程的效率提高

* 需要遍历子串中的每个字符，算法整体效率没有提高

  

需要巧妙设计哈希算法。假设主串中只包含K个字符，用一个K进制数表示一个子串，这个K进制数转换成10进制，作为子串的哈希值。

**EG:**

* 主串中只包含a~z这26个小写字母，用26进制表示一个字符串。把a~z映射到0~25这26个数字。
* 例如“cba”这个字符串就可以这样表示

![1561382945865](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1561382945865.png)

* 这种哈希算法有个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系

![1561383139387](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1561383139387.png)

* 相邻两个子串 s[i-1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m）对应的哈希值计算公式有交集

![1561383436669](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1561383436669.png)

* 26^(m-1) 这部分的计算，可以通过查表来提高效率。事先算好26^0、26^1、26^2…26^(m-1)的值，并且存储在一个长度为 m 的数组中。次方对应数组下标，省去计算时间

  ![1561383820848](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1561383820848.png)

  **时复分析：**

  * 计算子串哈希值：只要扫描一遍主串就可以计算出来，这部分时复O(n)

  * 匹配：模式串哈希值与每个子串哈希值比较时复为O(1)，总共要比较n-m+1个子串的哈希值，这部分时复O(n)

  * 整体的时间复杂度就是O(n)

    

  **不足：**

  如果模式串很长，相应的子串也很长，那么哈希值可能会超过计算机整型数据可表示的范围

  **解决方案：**

  上面的哈希算法没有散列冲突，允许散列冲突的话，可以将哈希值落在整型数据范围内。

  * 可以修改哈希算法，把字符串中每个字母对应的数字相加，最后得到的值作为哈希值，这样值就比较小。但是相应的，哈希冲突就挺高。
  * 发现一个子串哈希值跟模式串的哈希值相等时，只需要对比子串和模式串本身，如果两者不等，那么不匹配，继续遍历；如果相等，Ok，就匹配了。

**总结：**

哈希算法的冲突概率要控制得相对低一些，如果存在大量冲突，会导致RK算法时间复杂度退化，效率下降。

