# 5 | 为什么很多编程语言中数组都从0开始编号？

数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。

## 一、 数组如何实现随机访问

1. 数组是一种线性数据结构，用**连续的存储空间**存储**相同类型数据**

* **线性表**：数组、链表、队列、栈； **非线性表**：树、图

* 连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作

  1）数组如何实现下标随机访问
   引入数组在内存中的分配图，得出寻址公式。

  2）纠正数组和链表的错误认识

  **数组的查找操作时间复杂度并不是O(1)。**即便是排好的数组，用二分查找，时间复杂度也是O（logn）。
  正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）。

## 二、低效的插入和删除

1. 插入：最好O(1)、最坏O(n)、平均O(n)
2. 插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。
3. 删除：最好O(1)、最坏O(n)、平均O(n)
4. 多次删除集中在一起，提高删除效率
    记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。也就是JVM标记清除垃圾回收算法。

## 三、警惕数组的访问越界问题

`int main(int argc, char* argv[]){`
    `int i = 0;`
    `int arr[3] = {0};`
    `for(; i<=3; i++){`
        `arr[i] = 0;`
        `printf("hello world\n");`
    `}`
    `return 0;`
`}`

我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于i=0，所以就会导致代码无限循环。

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。

## 四、容器能否完全替代数组

相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。

**数组适合的场景：**

1. Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组
2. 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
3. 表示多维数组时，数组往往更加直观。
4. 业务开发容器即可；底层开发，如网络框架、性能优化，选择数组。

## 五、解答开篇问题

现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

1.  从偏移角度理解：如果用 a 来表示数组的首地址，a[0] 偏移量为 0，a[k] 就表示偏移 k 个 type_size 的位置：

   `a[k]_address = base_address + k * type_size` 

   如果从1计数，计算数组元素 a[k] 的内存地址就会变为：

   `a[k]_address = base_address + (k-1)*type_size`

   每次随机访问数组元素都多了一次减法运算，增加CPU负担。

   为什么循环要写成for(int i = 0;i<3;i++) 而不是for(int i = 0 ;i<=2;i++)。第一个直接就可以算出 3 - 0 = 3 有三个数据，而后者 2 - 0 + 1个数据，多出1个加法运算、、。

2. 也有一定的历史原因